# 次にやるべきこと（優先順）

## Step 1: stars.txtの圧縮（l/- → コンパクト k/D/X/-）

stars.txtをストリーム処理して、SKIコンビネータパターンを検出・置換。

**重要**: 単純な文字列置換ではダメ。木構造として正しくパースする必要がある。
スタックアルゴリズムでパースし、完全な部分木がSKIパターンに一致するかチェック。

### 実装方針
```python
# スタックベースのパーサー
# l → leafをpush
# - → pop 2つ、(X Y)を作ってpush
# 各部分木について、既知のSKIパターンと照合
```

ただしreference.mdではこれは既に完了報告あり（30,485,221文字に圧縮）。
→ まずreference.mdの分析結果を信頼して先に進むか、自前で検証するか。

## Step 2: コンパクト文字列のパースと構造分離

30MBのコンパクト文字列をバイナリ木にパース。
トップレベルで LEFT と RIGHT を分離。

## Step 3: reverse bracket abstraction

### 小さい部分から試す
まずDATA_CHAINの小さいアイテム（87文字、45文字など）でrevert()を試す。
正しく動くことを確認してから大きな部分に適用。

### デコーダー部（LEFT, ~152K文字）に適用
ラムダ式に変換し、既知の演算子パターンと照合。

## Step 4: プログラム理解

復元されたデコーダーが何をしているか読み解く。
- format/output系の処理
- 画像データの処理ロジック
- 暗号化/変換の方法

## Step 5: データの処理

デコーダーの理解に基づいてDATA_CHAIN全体を処理。
- GMヒント: 「データ部全体は画像データで暗号化されている」
- DATA_CHAIN 25アイテムそれぞれの役割を特定する必要がある:
  - アイテム9 (301K文字, 再帰構造) → 画像本体の可能性が高いが未確定
  - アイテム2 (33個の数値列), アイテム19 (5個の数値列) → 鍵、パラメータ、ヘッダ等の可能性
  - アイテム0,4,17 (pair構造) → 設定やメタデータの可能性
  - K leaves, セパレータ → 構造的区切りやデフォルト値
- デコーダープログラムがこれらをどう組み合わせて処理するかを先に理解すべき
- 最終的に4096幅で画像として出力（GMヒントより）

---

## 現実的に今すぐできること

### Option A: Pythonスクリプトを書く（推奨）
1. stars.txtを読んでスタックベースでパース
2. コンパクト圧縮
3. 構造分離
4. reverse bracket abstraction
5. 結果をファイルに出力

**問題**: 400MBのファイル処理にメモリと時間がかかる

### Option B: 既に解析済みの構造情報から作業
reference.mdの分析結果（トップレベル構造、DATA_CHAIN等）を信頼し、
そこから先の「ラムダ式変換」「プログラム読解」に注力。

### 推奨: Option A → B のハイブリッド
まずStep 1の圧縮を自前で実行（検証も兼ねて）。
成功したらreference.mdの構造分析と突き合わせ、
そこからreverse bracket abstractionに進む。

## 注意事項

- 400MBファイルの処理は時間がかかる。ストリーム処理必須
- SKIの木はメモリに載りきらない可能性がある → 部分的に処理する戦略
- GMヒント: 「チャーチエンコーディングではない」→ Scottエンコーディング
- 数値列の文字マッピングが最後の鍵になる可能性
