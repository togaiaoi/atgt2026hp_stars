# 次にやるべきこと（優先順）

## Step 1: stars.txtの圧縮（l/- → コンパクト k/D/X/-）

stars.txtをストリーム処理して、SKIコンビネータパターンを検出・置換。

**重要**: 単純な文字列置換ではダメ。木構造として正しくパースする必要がある。
スタックアルゴリズムでパースし、完全な部分木がSKIパターンに一致するかチェック。

### 実装方針
```python
# スタックベースのパーサー
# l → leafをpush
# - → pop 2つ、(X Y)を作ってpush
# 各部分木について、既知のSKIパターンと照合
```

ただしreference.mdではこれは既に完了報告あり（30,485,221文字に圧縮）。
→ まずreference.mdの分析結果を信頼して先に進むか、自前で検証するか。

## Step 2: コンパクト文字列のパースと構造分離

30MBのコンパクト文字列をバイナリ木にパース。
トップレベルで LEFT と RIGHT を分離。

## Step 3: reverse bracket abstraction

### 小さい部分から試す
まずDATA_CHAINの小さいアイテム（87文字、45文字など）でrevert()を試す。
正しく動くことを確認してから大きな部分に適用。

### デコーダー部（LEFT, ~152K文字）に適用
ラムダ式に変換し、既知の演算子パターンと照合。

## Step 4: プログラム理解

復元されたデコーダーが何をしているか読み解く。
- format/output系の処理
- 画像データの処理ロジック
- 暗号化/変換の方法

## Step 5: データの処理

デコーダーの理解に基づいてデータ部を処理。
- アイテム9 (301K) が画像データ
- 4096幅で画像として出力
- 暗号の解読

---

## 現実的に今すぐできること

### Option A: Pythonスクリプトを書く（推奨）
1. stars.txtを読んでスタックベースでパース
2. コンパクト圧縮
3. 構造分離
4. reverse bracket abstraction
5. 結果をファイルに出力

**問題**: 400MBのファイル処理にメモリと時間がかかる

### Option B: 既に解析済みの構造情報から作業
reference.mdの分析結果（トップレベル構造、DATA_CHAIN等）を信頼し、
そこから先の「ラムダ式変換」「プログラム読解」に注力。

### 推奨: Option A → B のハイブリッド
まずStep 1の圧縮を自前で実行（検証も兼ねて）。
成功したらreference.mdの構造分析と突き合わせ、
そこからreverse bracket abstractionに進む。

## 注意事項

- 400MBファイルの処理は時間がかかる。ストリーム処理必須
- SKIの木はメモリに載りきらない可能性がある → 部分的に処理する戦略
- GMヒント: 「チャーチエンコーディングではない」→ Scottエンコーディング
- 数値列の文字マッピングが最後の鍵になる可能性
